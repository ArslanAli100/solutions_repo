{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Here's a detailed explanation of projectile motion, including its governing equations, derivations, and graphical representations. Projectile Motion: Theory and Analysis 1. Introduction Projectile motion refers to the motion of an object that is launched into the air and moves under the influence of gravity alone, assuming air resistance is negligible. It is a fundamental concept in physics with applications in sports, engineering, and astrophysics. The motion of the projectile can be broken down into horizontal (x-direction) and vertical (y-direction) components, each governed by Newton's laws of motion. 2. Equations of Motion 2.1 Assumptions The projectile is launched from an initial height \\( y_0 = 0 \\) . Air resistance is neglected. The acceleration due to gravity ( \\( g \\) ) is constant and acts downward. The initial velocity \\( v_0 \\) is at an angle \\( \\theta \\) with the horizontal axis. 2.2 Decomposing Initial Velocity The initial velocity \\( v_0 \\) is split into horizontal and vertical components: $$ v_{0x} = v_0 \\cos\\theta $$ $$ v_{0y} = v_0 \\sin\\theta $$ 3. Horizontal Motion Since there is no horizontal acceleration (neglecting air resistance), the horizontal displacement \\( x \\) after time \\( t \\) is given by: \\[ x = v_{0x} t = v_0 \\cos\\theta \\cdot t \\] The horizontal velocity remains constant: \\[ v_x = v_0 \\cos\\theta \\] 4. Vertical Motion The vertical motion is influenced by gravity. Using kinematic equations: \\[ y = v_{0y} t - \\frac{1}{2} g t^2 \\] The vertical velocity at time \\( t \\) is: \\[ v_y = v_{0y} - g t \\] The projectile reaches its maximum height when \\( v_y = 0 \\) , which occurs at: \\[ t_{\\text{max}} = \\frac{v_0 \\sin\\theta}{g} \\] The maximum height ( \\( H \\) ) is given by: \\[ H = \\frac{(v_0 \\sin\\theta)^2}{2g} \\] 5. Time of Flight The total time the projectile spends in the air is found by setting \\( y = 0 \\) in the vertical displacement equation: \\[ 0 = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] Solving for \\( t \\) : \\[ t = \\frac{2 v_0 \\sin\\theta}{g} \\] 6. Range of the Projectile The range \\( R \\) is the total horizontal distance traveled before the projectile lands: \\[ R = v_{0x} \\cdot t \\] Substituting \\( v_{0x} = v_0 \\cos\\theta \\) and the total time of flight: \\[ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} \\] Using the trigonometric identity \\( 2\\sin\\theta\\cos\\theta = \\sin(2\\theta) \\) : \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] The maximum range occurs when \\( \\theta = 45^\\circ \\) , giving: \\[ R_{\\text{max}} = \\frac{v_0^2}{g} \\] 7. Graphical Representation Let's visualize how the range varies with launch angle. Python Code for Simulation This script plots: The trajectory of a projectile. The range as a function of launch angle. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravity (m/s^2) v0 = 20 # Initial velocity (m/s) angles = np.linspace(0, 90, 100) # Launch angles from 0 to 90 degrees # Function to compute projectile range def projectile_range(theta, v0, g=9.81): theta_rad = np.radians(theta) return (v0**2 * np.sin(2 * theta_rad)) / g # Compute ranges for different angles ranges = [projectile_range(theta, v0) for theta in angles] # Trajectory Simulation for a specific angle (e.g., 45\u00b0) theta_trajectory = 45 # Change this to see different angles t_flight = (2 * v0 * np.sin(np.radians(theta_trajectory))) / g t = np.linspace(0, t_flight, num=100) x = v0 * np.cos(np.radians(theta_trajectory)) * t y = v0 * np.sin(np.radians(theta_trajectory)) * t - 0.5 * g * t**2 # Plot 1: Projectile Trajectory plt.figure(figsize=(8, 6)) plt.plot(x, y, label=f'Trajectory at {theta_trajectory}\u00b0', color='b') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.title('Projectile Motion Trajectory') plt.legend() plt.grid() plt.show() # Plot 2: Range vs Angle plt.figure(figsize=(8, 6)) plt.plot(angles, ranges, label=f'Initial velocity: {v0} m/s', color='r') plt.axvline(45, linestyle=\"--\", color=\"b\", label=\"Max range at 45\u00b0\") plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() Graph Analysis Trajectory Plot : Shows the parabolic path followed by the projectile. Range vs. Angle : Demonstrates that the range is maximized at \\( 45^\\circ \\) . 8. Practical Applications Sports \u2013 Optimizing the angle for maximum distance in javelin throws, soccer kicks, or basketball shots. Military \u2013 Calculating projectile trajectories for artillery and missiles. Engineering \u2013 Predicting motion paths in robotics and mechanical systems. Astrophysics \u2013 Understanding planetary orbits and space vehicle trajectories. 9. Extensions To make the model more realistic, we can: - Introduce air resistance using drag force proportional to velocity. - Consider uneven terrain , where the landing height differs from the launch height. - Include wind effects , adding a horizontal acceleration component. 10. Conclusion Projectile motion is a fundamental concept with rich mathematical structures and numerous applications. By understanding its governing equations, we can predict and optimize trajectories in various real-world scenarios.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Here's a detailed explanation of projectile motion, including its governing equations, derivations, and graphical representations.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-theory-and-analysis","text":"","title":"Projectile Motion: Theory and Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-introduction","text":"Projectile motion refers to the motion of an object that is launched into the air and moves under the influence of gravity alone, assuming air resistance is negligible. It is a fundamental concept in physics with applications in sports, engineering, and astrophysics. The motion of the projectile can be broken down into horizontal (x-direction) and vertical (y-direction) components, each governed by Newton's laws of motion.","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-equations-of-motion","text":"","title":"2. Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-assumptions","text":"The projectile is launched from an initial height \\( y_0 = 0 \\) . Air resistance is neglected. The acceleration due to gravity ( \\( g \\) ) is constant and acts downward. The initial velocity \\( v_0 \\) is at an angle \\( \\theta \\) with the horizontal axis.","title":"2.1 Assumptions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-decomposing-initial-velocity","text":"The initial velocity \\( v_0 \\) is split into horizontal and vertical components: $$ v_{0x} = v_0 \\cos\\theta $$ $$ v_{0y} = v_0 \\sin\\theta $$","title":"2.2 Decomposing Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-horizontal-motion","text":"Since there is no horizontal acceleration (neglecting air resistance), the horizontal displacement \\( x \\) after time \\( t \\) is given by: \\[ x = v_{0x} t = v_0 \\cos\\theta \\cdot t \\] The horizontal velocity remains constant: \\[ v_x = v_0 \\cos\\theta \\]","title":"3. Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-vertical-motion","text":"The vertical motion is influenced by gravity. Using kinematic equations: \\[ y = v_{0y} t - \\frac{1}{2} g t^2 \\] The vertical velocity at time \\( t \\) is: \\[ v_y = v_{0y} - g t \\] The projectile reaches its maximum height when \\( v_y = 0 \\) , which occurs at: \\[ t_{\\text{max}} = \\frac{v_0 \\sin\\theta}{g} \\] The maximum height ( \\( H \\) ) is given by: \\[ H = \\frac{(v_0 \\sin\\theta)^2}{2g} \\]","title":"4. Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-time-of-flight","text":"The total time the projectile spends in the air is found by setting \\( y = 0 \\) in the vertical displacement equation: \\[ 0 = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] Solving for \\( t \\) : \\[ t = \\frac{2 v_0 \\sin\\theta}{g} \\]","title":"5. Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-range-of-the-projectile","text":"The range \\( R \\) is the total horizontal distance traveled before the projectile lands: \\[ R = v_{0x} \\cdot t \\] Substituting \\( v_{0x} = v_0 \\cos\\theta \\) and the total time of flight: \\[ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} \\] Using the trigonometric identity \\( 2\\sin\\theta\\cos\\theta = \\sin(2\\theta) \\) : \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] The maximum range occurs when \\( \\theta = 45^\\circ \\) , giving: \\[ R_{\\text{max}} = \\frac{v_0^2}{g} \\]","title":"6. Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#7-graphical-representation","text":"Let's visualize how the range varies with launch angle.","title":"7. Graphical Representation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-for-simulation","text":"This script plots: The trajectory of a projectile. The range as a function of launch angle. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravity (m/s^2) v0 = 20 # Initial velocity (m/s) angles = np.linspace(0, 90, 100) # Launch angles from 0 to 90 degrees # Function to compute projectile range def projectile_range(theta, v0, g=9.81): theta_rad = np.radians(theta) return (v0**2 * np.sin(2 * theta_rad)) / g # Compute ranges for different angles ranges = [projectile_range(theta, v0) for theta in angles] # Trajectory Simulation for a specific angle (e.g., 45\u00b0) theta_trajectory = 45 # Change this to see different angles t_flight = (2 * v0 * np.sin(np.radians(theta_trajectory))) / g t = np.linspace(0, t_flight, num=100) x = v0 * np.cos(np.radians(theta_trajectory)) * t y = v0 * np.sin(np.radians(theta_trajectory)) * t - 0.5 * g * t**2 # Plot 1: Projectile Trajectory plt.figure(figsize=(8, 6)) plt.plot(x, y, label=f'Trajectory at {theta_trajectory}\u00b0', color='b') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.title('Projectile Motion Trajectory') plt.legend() plt.grid() plt.show() # Plot 2: Range vs Angle plt.figure(figsize=(8, 6)) plt.plot(angles, ranges, label=f'Initial velocity: {v0} m/s', color='r') plt.axvline(45, linestyle=\"--\", color=\"b\", label=\"Max range at 45\u00b0\") plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show()","title":"Python Code for Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graph-analysis","text":"Trajectory Plot : Shows the parabolic path followed by the projectile. Range vs. Angle : Demonstrates that the range is maximized at \\( 45^\\circ \\) .","title":"Graph Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#8-practical-applications","text":"Sports \u2013 Optimizing the angle for maximum distance in javelin throws, soccer kicks, or basketball shots. Military \u2013 Calculating projectile trajectories for artillery and missiles. Engineering \u2013 Predicting motion paths in robotics and mechanical systems. Astrophysics \u2013 Understanding planetary orbits and space vehicle trajectories.","title":"8. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#9-extensions","text":"To make the model more realistic, we can: - Introduce air resistance using drag force proportional to velocity. - Consider uneven terrain , where the landing height differs from the launch height. - Include wind effects , adding a horizontal acceleration component.","title":"9. Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#10-conclusion","text":"Projectile motion is a fundamental concept with rich mathematical structures and numerous applications. By understanding its governing equations, we can predict and optimize trajectories in various real-world scenarios.","title":"10. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Theoretical Foundation: Forced Damped Pendulum The motion of a forced damped pendulum is governed by the following differential equation: \\[ \\theta''(t) + \\gamma \\theta'(t) + \\omega_0^2 \\sin(\\theta(t)) = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) is the angular displacement of the pendulum as a function of time, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the pendulum (where \\(g\\) is the gravitational acceleration and \\(L\\) is the length of the pendulum), - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the frequency of the external driving force. Small-Angle Approximation For small-angle oscillations ( \\(\\theta \\ll 1\\) ), we can approximate \\(\\sin(\\theta) \\approx \\theta\\) , simplifying the differential equation to: \\[ \\theta''(t) + \\gamma \\theta'(t) + \\omega_0^2 \\theta(t) = A \\cos(\\omega t) \\] This is a second-order linear non-homogeneous differential equation that describes the dynamics of the forced damped pendulum. Resonance Conditions Resonance occurs when the frequency of the external force ( \\(\\omega\\) ) matches the natural frequency of the pendulum ( \\(\\omega_0\\) ). In this case, the pendulum experiences large oscillations due to constructive interference between the driving force and the system\u2019s natural response. The resonance condition is: \\[ \\omega = \\omega_0 \\] At resonance, the amplitude of oscillation increases significantly. The damping term ( \\(\\gamma\\) ) affects the sharpness of the resonance peak, with stronger damping resulting in a broader and lower resonance. Analysis of Dynamics To explore the dynamics of the forced damped pendulum, we focus on the effects of the following parameters: Damping Coefficient ( \\(\\gamma\\) ) : Underdamped : If \\(\\gamma\\) is small, the system oscillates with gradually decreasing amplitude. Critically Damped : If \\(\\gamma\\) is tuned just right, the system returns to equilibrium as quickly as possible without oscillating. Overdamped : If \\(\\gamma\\) is large, the system returns to equilibrium without oscillating but more slowly than the critically damped case. Driving Amplitude (A) : Higher driving amplitudes increase the maximum displacement of the pendulum, especially near resonance. Driving Frequency ( \\(\\omega\\) ) : When the driving frequency is close to the natural frequency, resonance occurs, leading to larger oscillations. Far from resonance, the pendulum oscillates at the driving frequency with smaller amplitudes. Transition Between Regular and Chaotic Motion : As the driving frequency or amplitude is varied, the pendulum can transition from periodic motion to chaotic behavior. This transition is characterized by the system\u2019s sensitivity to initial conditions, which is a hallmark of chaotic systems. Practical Applications The forced damped pendulum model has many real-world applications, including: Energy Harvesting Devices : By tuning the pendulum\u2019s resonance to match environmental vibrations, it can efficiently harvest energy from periodic external forces. Suspension Bridges : The motion of suspension bridges under periodic wind forces can be modeled by a forced damped pendulum. Engineers must account for resonance to prevent catastrophic failure. Oscillating Circuits (Driven RLC Circuits) : A driven RLC circuit exhibits similar dynamics to a forced damped pendulum, where the current oscillates due to an external driving voltage. Computational Implementation We will create a computational model of the forced damped pendulum and simulate its motion under various conditions. The steps are as follows: Define the Differential Equation : We can define the equation using Python and solve it numerically. Use Numerical Methods (e.g., Runge-Kutta) : The equation is solved numerically using techniques like the Runge-Kutta method, which is effective for stiff equations. Visualize the Behavior : Phase diagrams and Poincar\u00e9 sections will be plotted to visualize transitions to chaos. Amplitude vs. frequency plots will be created to explore resonance. Python Code Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters gamma = 0.1 # Damping coefficient omega_0 = 2.0 # Natural frequency A = 1.0 # Amplitude of the driving force omega = 1.5 # Driving frequency theta0 = 0.1 # Initial angle (in radians) theta_dot0 = 0.0 # Initial angular velocity # Define the equation of motion def pendulum(t, y, gamma, omega_0, A, omega): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # Initial conditions y0 = [theta0, theta_dot0] # Time span for the solution t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 10000) # Solve the differential equation sol = solve_ivp(pendulum, t_span, y0, args=(gamma, omega_0, A, omega), t_eval=t_eval) # Plot the results plt.figure(figsize=(10, 6)) plt.plot(sol.t, sol.y[0], label='Theta(t)') plt.title('Forced Damped Pendulum') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.legend() plt.grid(True) plt.show() # Phase space plot (theta vs theta_dot) plt.figure(figsize=(10, 6)) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Space Plot') plt.xlabel('Theta (radians)') plt.ylabel('Theta_dot (rad/s)') plt.grid(True) plt.show() Discussion This Python code implements the forced damped pendulum model, solving the differential equation using the solve_ivp function from SciPy. The results are plotted to visualize the pendulum's motion over time and its phase space. By varying parameters such as the damping coefficient, driving amplitude, and frequency, the system\u2019s behavior can be explored. A resonance peak will appear in the amplitude vs. frequency plot when \\(\\omega \\approx \\omega_0\\) . Limitations and Extensions Limitations of the Model : The small-angle approximation \\(\\sin(\\theta) \\approx \\theta\\) is only valid for small displacements. For larger angles, the full nonlinear equation should be used. The model assumes a linear damping force. In reality, damping may be nonlinear, especially at high velocities. Potential Extensions : Nonlinear Damping : Introducing a nonlinear damping term could lead to more complex behavior, such as limit cycles or bifurcations. Non-Periodic Driving Forces : Exploring non-sinusoidal driving forces (e.g., square waves or random noise) could add complexity and model more realistic external forcing. Conclusion The forced damped pendulum offers a rich framework for studying nonlinear oscillatory systems. The system exhibits regular, resonant, and chaotic behavior, depending on the values of the damping coefficient, driving amplitude, and frequency. The analysis and simulation of such systems are essential in various engineering applications, such as vibration isolation, energy harvesting, and mechanical resonance.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation-forced-damped-pendulum","text":"The motion of a forced damped pendulum is governed by the following differential equation: \\[ \\theta''(t) + \\gamma \\theta'(t) + \\omega_0^2 \\sin(\\theta(t)) = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) is the angular displacement of the pendulum as a function of time, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the pendulum (where \\(g\\) is the gravitational acceleration and \\(L\\) is the length of the pendulum), - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the frequency of the external driving force.","title":"Theoretical Foundation: Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small-angle oscillations ( \\(\\theta \\ll 1\\) ), we can approximate \\(\\sin(\\theta) \\approx \\theta\\) , simplifying the differential equation to: \\[ \\theta''(t) + \\gamma \\theta'(t) + \\omega_0^2 \\theta(t) = A \\cos(\\omega t) \\] This is a second-order linear non-homogeneous differential equation that describes the dynamics of the forced damped pendulum.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the frequency of the external force ( \\(\\omega\\) ) matches the natural frequency of the pendulum ( \\(\\omega_0\\) ). In this case, the pendulum experiences large oscillations due to constructive interference between the driving force and the system\u2019s natural response. The resonance condition is: \\[ \\omega = \\omega_0 \\] At resonance, the amplitude of oscillation increases significantly. The damping term ( \\(\\gamma\\) ) affects the sharpness of the resonance peak, with stronger damping resulting in a broader and lower resonance.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analysis-of-dynamics","text":"To explore the dynamics of the forced damped pendulum, we focus on the effects of the following parameters: Damping Coefficient ( \\(\\gamma\\) ) : Underdamped : If \\(\\gamma\\) is small, the system oscillates with gradually decreasing amplitude. Critically Damped : If \\(\\gamma\\) is tuned just right, the system returns to equilibrium as quickly as possible without oscillating. Overdamped : If \\(\\gamma\\) is large, the system returns to equilibrium without oscillating but more slowly than the critically damped case. Driving Amplitude (A) : Higher driving amplitudes increase the maximum displacement of the pendulum, especially near resonance. Driving Frequency ( \\(\\omega\\) ) : When the driving frequency is close to the natural frequency, resonance occurs, leading to larger oscillations. Far from resonance, the pendulum oscillates at the driving frequency with smaller amplitudes. Transition Between Regular and Chaotic Motion : As the driving frequency or amplitude is varied, the pendulum can transition from periodic motion to chaotic behavior. This transition is characterized by the system\u2019s sensitivity to initial conditions, which is a hallmark of chaotic systems.","title":"Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications","text":"The forced damped pendulum model has many real-world applications, including: Energy Harvesting Devices : By tuning the pendulum\u2019s resonance to match environmental vibrations, it can efficiently harvest energy from periodic external forces. Suspension Bridges : The motion of suspension bridges under periodic wind forces can be modeled by a forced damped pendulum. Engineers must account for resonance to prevent catastrophic failure. Oscillating Circuits (Driven RLC Circuits) : A driven RLC circuit exhibits similar dynamics to a forced damped pendulum, where the current oscillates due to an external driving voltage.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#computational-implementation","text":"We will create a computational model of the forced damped pendulum and simulate its motion under various conditions. The steps are as follows: Define the Differential Equation : We can define the equation using Python and solve it numerically. Use Numerical Methods (e.g., Runge-Kutta) : The equation is solved numerically using techniques like the Runge-Kutta method, which is effective for stiff equations. Visualize the Behavior : Phase diagrams and Poincar\u00e9 sections will be plotted to visualize transitions to chaos. Amplitude vs. frequency plots will be created to explore resonance.","title":"Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters gamma = 0.1 # Damping coefficient omega_0 = 2.0 # Natural frequency A = 1.0 # Amplitude of the driving force omega = 1.5 # Driving frequency theta0 = 0.1 # Initial angle (in radians) theta_dot0 = 0.0 # Initial angular velocity # Define the equation of motion def pendulum(t, y, gamma, omega_0, A, omega): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # Initial conditions y0 = [theta0, theta_dot0] # Time span for the solution t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 10000) # Solve the differential equation sol = solve_ivp(pendulum, t_span, y0, args=(gamma, omega_0, A, omega), t_eval=t_eval) # Plot the results plt.figure(figsize=(10, 6)) plt.plot(sol.t, sol.y[0], label='Theta(t)') plt.title('Forced Damped Pendulum') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.legend() plt.grid(True) plt.show() # Phase space plot (theta vs theta_dot) plt.figure(figsize=(10, 6)) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Space Plot') plt.xlabel('Theta (radians)') plt.ylabel('Theta_dot (rad/s)') plt.grid(True) plt.show()","title":"Python Code Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#discussion","text":"This Python code implements the forced damped pendulum model, solving the differential equation using the solve_ivp function from SciPy. The results are plotted to visualize the pendulum's motion over time and its phase space. By varying parameters such as the damping coefficient, driving amplitude, and frequency, the system\u2019s behavior can be explored. A resonance peak will appear in the amplitude vs. frequency plot when \\(\\omega \\approx \\omega_0\\) .","title":"Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations-and-extensions","text":"Limitations of the Model : The small-angle approximation \\(\\sin(\\theta) \\approx \\theta\\) is only valid for small displacements. For larger angles, the full nonlinear equation should be used. The model assumes a linear damping force. In reality, damping may be nonlinear, especially at high velocities. Potential Extensions : Nonlinear Damping : Introducing a nonlinear damping term could lead to more complex behavior, such as limit cycles or bifurcations. Non-Periodic Driving Forces : Exploring non-sinusoidal driving forces (e.g., square waves or random noise) could add complexity and model more realistic external forcing.","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum offers a rich framework for studying nonlinear oscillatory systems. The system exhibits regular, resonant, and chaotic behavior, depending on the values of the damping coefficient, driving amplitude, and frequency. The analysis and simulation of such systems are essential in various engineering applications, such as vibration isolation, energy harvesting, and mechanical resonance.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 To solve this problem, we will derive Kepler's Third Law for circular orbits, discuss its astronomical implications, analyze real-world examples, and implement a computational model to verify the relationship. Derivation of Kepler's Third Law for Circular Orbits For a circular orbit, the gravitational force provides the centripetal force: [G M m r 2 = m v 2 r r 2 \\cos\\theta ] GMm \u200b = r mv 2 \u200b Simplifying, we find: v G M r v= r GM \u200b \u200b The orbital velocity v v relates to the orbital period T T as v = 2 \u03c0 r T v= T 2\u03c0r \u200b . Substituting: 2 \u03c0 r T = G M r T 2\u03c0r \u200b = r GM \u200b \u200b Rearranging gives Kepler's Third Law: T 2 = 4 \u03c0 2 G M r 3 T 2 = GM 4\u03c0 2 \u200b r 3 Thus, T 2 \u221d r 3 T 2 \u221dr 3 . Astronomical Implications Planetary Masses: By observing T T and r r of a satellite, we calculate the central body's mass M M. Exoplanet Detection: Doppler shifts and transit timing rely on this law to estimate exoplanet masses and orbits. Satellite Deployment: Ensures satellites have correct orbital periods for geostationary or low Earth orbits. Real-World Examples Moon's Orbit: T \u2248 27.3 T\u224827.3 days, r \u2248 384 , 400 r\u2248384,400 km. Using T 2 \u221d r 3 T 2 \u221dr 3 , Earth's mass is accurately calculated. Solar System Planets: Mercury to Neptune follow T 2 \u221d r 3 T 2 \u221dr 3 , validating Kepler's Law. Computational Model and Verification We simulate circular orbits using Velocity Verlet integration to minimize numerical errors and verify T 2 \u221d r 3 T 2 \u221dr 3 . python Copy import numpy as np import matplotlib.pyplot as plt Constants G = 6.67430e-11 # m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 M_earth = 5.972e24 # kg def kepler_period(r): return np.sqrt(4 * np.pi 2 * r 3 / (G * M_earth)) def simulate_orbit(r, dt=100, total_time=1e6): x, y = r, 0 vx, vy = 0, np.sqrt(G * M_earth / r) ax_prev = -G * M_earth * x / (x 2 + y 2)**1.5 ay_prev = 0 xs, ys = [x], [y] num_steps = int(total_time / dt) for _ in range(num_steps): # Update position x_new = x + vx * dt + 0.5 * ax_prev * dt**2 y_new = y + vy * dt + 0.5 * ay_prev * dt**2 # New acceleration r_mag = np.sqrt(x_new**2 + y_new**2) ax_new = -G * M_earth * x_new / r_mag**3 ay_new = -G * M_earth * y_new / r_mag**3 # Update velocity vx += 0.5 * (ax_prev + ax_new) * dt vy += 0.5 * (ay_prev + ay_new) * dt x, y = x_new, y_new ax_prev, ay_prev = ax_new, ay_new xs.append(x) ys.append(y) return xs, ys Plot T\u00b2 vs r\u00b3 r_values = np.linspace(1e6, 1e8, 100) T_values = kepler_period(r_values) plt.figure(figsize=(10, 5)) plt.plot(r_values 3, T_values 2, 'b-') plt.xlabel('Orbital Radius Cubed (m\u00b3)') plt.ylabel('Orbital Period Squared (s\u00b2)') plt.title(\"Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid(True) plt.show() Log-log plot to show slope plt.figure(figsize=(10, 5)) plt.loglog(r_values, T_values, 'r-') plt.xlabel('Orbital Radius (m)') plt.ylabel('Orbital Period (s)') slope = np.polyfit(np.log(r_values), np.log(T_values), 1)[0] plt.title(f'Log-Log Plot (Slope = {slope:.2f})') plt.grid(True) plt.show() Simulate and plot orbit r_example = 4.2e7 # Geostationary orbit radius xs, ys = simulate_orbit(r_example, dt=100, total_time=1e6) plt.figure(figsize=(8, 8)) plt.plot(xs, ys) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Simulated Circular Orbit') plt.axis('equal') plt.grid(True) plt.show() Graphical Representations T\u00b2 vs r\u00b3: A linear plot confirming T 2 \u221d r 3 T 2 \u221dr 3 . Log-Log Plot: Slope \u2248 1.5, verifying T \u221d r 3 / 2 T\u221dr 3/2 . Orbit Simulation: Visual confirmation of a stable circular path. Elliptical Orbits Extension For elliptical orbits, Kepler's Law uses the semi-major axis a a: T 2 = 4 \u03c0 2 G ( M + m ) a 3 T 2 = G(M+m) 4\u03c0 2 \u200b a 3 When M \u226b m M\u226bm, it simplifies to the same form, enabling applications to comets, binary stars, and galaxies. Conclusion Kepler's Third Law is pivotal in celestial mechanics, enabling mass calculations and orbital predictions. The computational model confirms the theoretical relationship, underscoring its universality for circular and elliptical orbits.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"To solve this problem, we will derive Kepler's Third Law for circular orbits, discuss its astronomical implications, analyze real-world examples, and implement a computational model to verify the relationship. Derivation of Kepler's Third Law for Circular Orbits For a circular orbit, the gravitational force provides the centripetal force: [G M m r 2 = m v 2 r r 2 \\cos\\theta ] GMm \u200b = r mv 2 \u200b Simplifying, we find:","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#v","text":"G M r v= r GM \u200b \u200b The orbital velocity v v relates to the orbital period T T as v = 2 \u03c0 r T v= T 2\u03c0r \u200b . Substituting: 2 \u03c0 r T = G M r T 2\u03c0r \u200b = r GM \u200b \u200b Rearranging gives Kepler's Third Law: T 2 = 4 \u03c0 2 G M r 3 T 2 = GM 4\u03c0 2 \u200b r 3 Thus, T 2 \u221d r 3 T 2 \u221dr 3 . Astronomical Implications Planetary Masses: By observing T T and r r of a satellite, we calculate the central body's mass M M. Exoplanet Detection: Doppler shifts and transit timing rely on this law to estimate exoplanet masses and orbits. Satellite Deployment: Ensures satellites have correct orbital periods for geostationary or low Earth orbits. Real-World Examples Moon's Orbit: T \u2248 27.3 T\u224827.3 days, r \u2248 384 , 400 r\u2248384,400 km. Using T 2 \u221d r 3 T 2 \u221dr 3 , Earth's mass is accurately calculated. Solar System Planets: Mercury to Neptune follow T 2 \u221d r 3 T 2 \u221dr 3 , validating Kepler's Law. Computational Model and Verification We simulate circular orbits using Velocity Verlet integration to minimize numerical errors and verify T 2 \u221d r 3 T 2 \u221dr 3 . python Copy import numpy as np import matplotlib.pyplot as plt","title":"v"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"G = 6.67430e-11 # m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 M_earth = 5.972e24 # kg def kepler_period(r): return np.sqrt(4 * np.pi 2 * r 3 / (G * M_earth)) def simulate_orbit(r, dt=100, total_time=1e6): x, y = r, 0 vx, vy = 0, np.sqrt(G * M_earth / r) ax_prev = -G * M_earth * x / (x 2 + y 2)**1.5 ay_prev = 0 xs, ys = [x], [y] num_steps = int(total_time / dt) for _ in range(num_steps): # Update position x_new = x + vx * dt + 0.5 * ax_prev * dt**2 y_new = y + vy * dt + 0.5 * ay_prev * dt**2 # New acceleration r_mag = np.sqrt(x_new**2 + y_new**2) ax_new = -G * M_earth * x_new / r_mag**3 ay_new = -G * M_earth * y_new / r_mag**3 # Update velocity vx += 0.5 * (ax_prev + ax_new) * dt vy += 0.5 * (ay_prev + ay_new) * dt x, y = x_new, y_new ax_prev, ay_prev = ax_new, ay_new xs.append(x) ys.append(y) return xs, ys","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plot-t2-vs-r3","text":"r_values = np.linspace(1e6, 1e8, 100) T_values = kepler_period(r_values) plt.figure(figsize=(10, 5)) plt.plot(r_values 3, T_values 2, 'b-') plt.xlabel('Orbital Radius Cubed (m\u00b3)') plt.ylabel('Orbital Period Squared (s\u00b2)') plt.title(\"Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid(True) plt.show()","title":"Plot T\u00b2 vs r\u00b3"},{"location":"1%20Physics/2%20Gravity/Problem_1/#log-log-plot-to-show-slope","text":"plt.figure(figsize=(10, 5)) plt.loglog(r_values, T_values, 'r-') plt.xlabel('Orbital Radius (m)') plt.ylabel('Orbital Period (s)') slope = np.polyfit(np.log(r_values), np.log(T_values), 1)[0] plt.title(f'Log-Log Plot (Slope = {slope:.2f})') plt.grid(True) plt.show()","title":"Log-log plot to show slope"},{"location":"1%20Physics/2%20Gravity/Problem_1/#simulate-and-plot-orbit","text":"r_example = 4.2e7 # Geostationary orbit radius xs, ys = simulate_orbit(r_example, dt=100, total_time=1e6) plt.figure(figsize=(8, 8)) plt.plot(xs, ys) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Simulated Circular Orbit') plt.axis('equal') plt.grid(True) plt.show() Graphical Representations T\u00b2 vs r\u00b3: A linear plot confirming T 2 \u221d r 3 T 2 \u221dr 3 . Log-Log Plot: Slope \u2248 1.5, verifying T \u221d r 3 / 2 T\u221dr 3/2 . Orbit Simulation: Visual confirmation of a stable circular path. Elliptical Orbits Extension For elliptical orbits, Kepler's Law uses the semi-major axis a a: T 2 = 4 \u03c0 2 G ( M + m ) a 3 T 2 = G(M+m) 4\u03c0 2 \u200b a 3 When M \u226b m M\u226bm, it simplifies to the same form, enabling applications to comets, binary stars, and galaxies. Conclusion Kepler's Third Law is pivotal in celestial mechanics, enabling mass calculations and orbital predictions. The computational model confirms the theoretical relationship, underscoring its universality for circular and elliptical orbits.","title":"Simulate and plot orbit"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"}]}